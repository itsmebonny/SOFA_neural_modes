import dolfinx
import dolfinx.fem as fem
import dolfinx.mesh as mesh
from dolfinx.fem import Function, FunctionSpace, Constant
# Removed: from dolfinx.mesh import create_unit_cube
from dolfinx.mesh import CellType # Keep CellType
from dolfinx.io import gmshio # <--- Import gmshio
from mpi4py import MPI
import ufl
import numpy as np
import torch
import sys
from pathlib import Path # <--- Import Path for file handling

# Import your PyTorch model class
try:
    from solver import UFLNeoHookeanModel # <--- MAKE SURE FILENAME IS CORRECT
except ImportError:
    print("ERROR: Could not import UFLNeoHookeanModel.")
    print("Make sure 'ufl_neohookean_model.py' (or the correct file) is accessible.")
    sys.exit(1)

# --- Configuration ---
COMM = MPI.COMM_WORLD
MODEL_RANK = 0

# Mesh parameters (Descriptive - Actual mesh loaded from file)
# NX, NY, NZ = 10, 1, 1 # Describes the intended beam structure
GMSH_FILENAME = "mesh/beam_732.msh" # <--- SET YOUR GMSH FILENAME HERE

# --- CRITICAL ---
# Set this based on the ELEMENT TYPE GENERATED BY GMSH in your .msh file!
# If Gmsh made tetrahedra -> CellType.tetrahedron
# If Gmsh made hexahedra -> CellType.hexahedron
MESH_CELL_TYPE = CellType.tetrahedron # <--- ADJUST IF NEEDED

DEGREE = 1 # FEM degree (must match assumption in torch model if fallback is used)

# Material parameters
E_val = 10000.0
nu_val = 0.35

# Comparison point indices
TEST_ELEMENT_IDX = 2
TEST_QUAD_POINT_IDX = 2

# PyTorch settings
DTYPE = torch.float64
DEVICE = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

# --- Neo-Hookean Formula Selection ---
USE_TORCH_INTERNAL_FORMULA = True

# --- Deformation Type ---
DEFORMATION_TYPE = 'shear' # 'stretch' or 'shear'
STRETCH_ALPHA = 1.1
SHEAR_GAMMA = 0.2

# --- Helper Functions (get_physical_coords, define_deformation - Keep as before) ---
# ... (Keep the helper functions from the previous version) ...
def get_physical_coords(domain, element_idx, ref_coords_list_np):
    """
    Calculate physical coordinates corresponding to reference coordinates
    within a specific element using dolfinx geometry.
    Tries to handle linear tet/hex.
    """
    try:
        # Ensure input is a list of numpy arrays or convert tensor list
        if isinstance(ref_coords_list_np, torch.Tensor):
             ref_coords_list_np = ref_coords_list_np.cpu().numpy()
        if not isinstance(ref_coords_list_np, (list, tuple)):
             ref_coords_list_np = [ref_coords_list_np] # Ensure iterable

        # Get geometry info for the specific element
        geom_dofmap = domain.geometry.dofmap
        element_geom_dofs = geom_dofmap.links(element_idx) # Indices into domain.geometry.x
        element_coords_dolfinx = domain.geometry.x[element_geom_dofs] # Coordinates of element's geometry nodes

        geom_element = domain.geometry.cmap # Element map for geometry
        if geom_element.is_lagrange: # Check if geometry uses Lagrange basis
             geom_degree = geom_element.degree

             # --- Shape function evaluation (simplistic implementation) ---
             phys_coords_list = []
             for ref_coord in ref_coords_list_np:
                 phys_coord = np.zeros(domain.geometry.dim)
                 # Use domain.topology.cell_name which is more robust after loading
                 cell_name = domain.topology.cell_name
                 if "tetrahedron" in cell_name and geom_degree == 1:
                     # Assume ref_coord is barycentric (L1, L2, L3), need L4
                     L = np.append(ref_coord, 1.0 - np.sum(ref_coord))
                     if len(L) != 4: raise ValueError("Barycentric coord needs 3 values for Tet")
                     phys_coord = np.sum(L[:, np.newaxis] * element_coords_dolfinx, axis=0)

                 elif "hexahedron" in cell_name and geom_degree == 1:
                     # Assume ref_coord is xi, eta, zeta in [-1, 1]
                     xi, eta, zeta = ref_coord
                     if len(ref_coord) != 3: raise ValueError("Reference coord needs 3 values for Hex")
                     N = np.array([ # Linear Hex shape functions
                         0.125 * (1 - xi) * (1 - eta) * (1 - zeta),
                         0.125 * (1 + xi) * (1 - eta) * (1 - zeta),
                         0.125 * (1 + xi) * (1 + eta) * (1 - zeta),
                         0.125 * (1 - xi) * (1 + eta) * (1 - zeta),
                         0.125 * (1 - xi) * (1 - eta) * (1 + zeta),
                         0.125 * (1 + xi) * (1 - eta) * (1 + zeta),
                         0.125 * (1 + xi) * (1 + eta) * (1 + zeta),
                         0.125 * (1 - xi) * (1 + eta) * (1 + zeta)
                     ])
                     phys_coord = np.sum(N[:, np.newaxis] * element_coords_dolfinx, axis=0)
                 else:
                     print(f"Warning: get_physical_coords approx for cell {cell_name} / degree {geom_degree}. Using centroid.")
                     phys_coord = np.mean(element_coords_dolfinx, axis=0)

                 phys_coords_list.append(phys_coord)

             return np.array(phys_coords_list) # Return array of physical points

        else:
             print("Warning: Geometry is not Lagrange based. Cannot evaluate shape functions easily. Returning centroid.")
             return np.mean(element_coords_dolfinx, axis=0, keepdims=True)

    except AttributeError as e:
         print(f"Error in get_physical_coords (AttributeError): {e}. Check dolfinx object properties.")
         # Fallback: return centroid(s)
         num_points = len(ref_coords_list_np)
         centroid = np.mean(domain.geometry.x[domain.geometry.dofmap.links(element_idx)], axis=0)
         return np.tile(centroid, (num_points, 1))
    except Exception as e:
         print(f"Error in get_physical_coords: {e}")
         # Fallback: return centroid(s)
         num_points = len(ref_coords_list_np)
         centroid = np.mean(domain.geometry.x[domain.geometry.dofmap.links(element_idx)], axis=0)
         return np.tile(centroid, (num_points, 1))

def define_deformation(x, deformation_type='stretch', alpha=1.1, gamma=0.2):
    """Defines displacement field u based on deformation type."""
    if deformation_type == 'stretch':
        return np.stack(((alpha - 1.0) * x[0], 0.0 * x[1], 0.0 * x[2]))
    elif deformation_type == 'shear':
        return np.stack((gamma * x[1], 0.0 * x[0], 0.0 * x[2]))
    else:
        raise ValueError(f"Unknown deformation type: {deformation_type}")

# --- Main Script Logic ---
if COMM.rank == MODEL_RANK:
    print("--- Debugging Neo-Hookean Energy Calculation ---")
    print(f"Loading Gmsh File: {GMSH_FILENAME}")
    print(f"EXPECTED Cell Type from Gmsh: {MESH_CELL_TYPE}") # User must ensure this matches
    print(f"Using Device: {DEVICE}, Precision: {DTYPE}")
    print(f"FEM Degree: {DEGREE}")
    print(f"Material: E={E_val}, nu={nu_val}")
    print(f"Comparing Element Index: {TEST_ELEMENT_IDX}, Quad Point Index: {TEST_QUAD_POINT_IDX}")
    print(f"Using Torch Internal Formula (J^2 term): {USE_TORCH_INTERNAL_FORMULA}")
    print(f"Deformation Type: {DEFORMATION_TYPE.upper()}")
    # ... (print alpha/gamma as before) ...
    if DEFORMATION_TYPE == 'stretch': print(f"  Stretch Alpha: {STRETCH_ALPHA}")
    if DEFORMATION_TYPE == 'shear': print(f"  Shear Gamma: {SHEAR_GAMMA}")
    print("-" * 50)

# 1. Load Mesh from Gmsh file
gmsh_file_path = Path(GMSH_FILENAME)
if COMM.rank == MODEL_RANK:
    if not gmsh_file_path.is_file():
        print(f"FATAL ERROR: Gmsh file not found at: {gmsh_file_path.resolve()}")
        COMM.Abort(1) # Abort all processes if file not found by rank 0

# Synchronize before potentially aborting
COMM.Barrier()

try:
    # All ranks read the mesh file; gmshio handles partitioning.
    # Assumes MESH_CELL_TYPE is set correctly based on the file content.
    # Pruning may be necessary depending on Gmsh physical group setup
    domain, cell_tags, facet_tags = gmshio.read_from_msh(str(gmsh_file_path), COMM, rank=MODEL_RANK, gdim=3) # gdim=3 for 3D problem
    if COMM.rank == MODEL_RANK:
        print(f"Gmsh mesh loaded successfully. Cell type: {domain.topology.cell_type}")
        # Verify loaded cell type matches expected type
        if MESH_CELL_TYPE != domain.topology.cell_type:
             print(f"WARNING: Loaded mesh cell type '{domain.topology.cell_type}' does not match configured MESH_CELL_TYPE '{MESH_CELL_TYPE}'. Check configuration.")
             print(f"         Proceeding, but PyTorch fallback/init might rely on MESH_CELL_TYPE.")
except Exception as e:
    if COMM.rank == MODEL_RANK:
        print(f"FATAL ERROR: Failed to load Gmsh file '{GMSH_FILENAME}'. Error: {e}")
    COMM.Abort(1) # Abort all processes on error

tdim = domain.topology.dim

# 2. Create Function Space (DOLFINx)
# Use the robust shortcut
try:
    V = fem.functionspace(domain, ("Lagrange", DEGREE, (tdim,)))
    if COMM.rank == MODEL_RANK: print("Using FunctionSpace shortcut for V.")
except Exception as e:
    if COMM.rank == MODEL_RANK:
        print(f"FATAL ERROR: Cannot create Vector FunctionSpace: {e}")
        print("Check DEGREE compatibility with the loaded mesh.")
    COMM.Abort(1)

# 3. Define and Interpolate Displacement (DOLFINx)
u = Function(V)
deformation_func = lambda x: define_deformation(x, deformation_type=DEFORMATION_TYPE,
                                                alpha=STRETCH_ALPHA, gamma=SHEAR_GAMMA)
try:
    u.interpolate(deformation_func)
    u.x.scatter_forward()
except Exception as e:
     if COMM.rank == MODEL_RANK:
        print(f"ERROR during interpolation: {e}")
        print("      Check if deformation_func is valid for the mesh domain.")
     COMM.Abort(1)

u_dof_values_np = u.x.array.copy()
num_total_dofs = V.dofmap.index_map.size_global * V.dofmap.index_map_bs

if COMM.rank == MODEL_RANK:
    print(f"DOLFINx Setup: Num Nodes={V.dofmap.index_map.size_global}, Dim={V.dofmap.index_map_bs}")
    print(f"Total DoFs = {num_total_dofs}")
    # print(f"Input u (first 15 vals): {u_dof_values_np[:15]}") # Maybe less useful for large unstructured meshes
    print("-" * 50)

# ==============================================
# 4. Initialize PyTorch Model
# ==============================================
# (Keep the PyTorch initialization block exactly as before)
# ...
pytorch_model_initialized = False
if COMM.rank == MODEL_RANK:
    print("Initializing PyTorch Model...")
    try:
        # Pass the loaded domain object
        torch_model = UFLNeoHookeanModel(
            domain=domain, # <--- Use the loaded domain
            degree=DEGREE,
            E=E_val,
            nu=nu_val,
            precompute_matrices=True,
            device=DEVICE,
            dtype=DTYPE
        )
        print("PyTorch Model Initialized.")
        if not (0 <= TEST_ELEMENT_IDX < torch_model.num_elements):
             raise IndexError("TEST_ELEMENT_IDX out of bounds!")
        if not (0 <= TEST_QUAD_POINT_IDX < torch_model.num_quad_points):
            raise IndexError("TEST_QUAD_POINT_IDX out of bounds!")
        pytorch_model_initialized = True
    except IndexError as e:
        print(f"\n!!! Configuration Error: {e}")
        torch_model = None
    except Exception as e:
        print(f"\n!!! Error initializing PyTorch model: {e}")
        import traceback
        traceback.print_exc() # Print full traceback for init errors
        print("Check prerequisites, paths, and model __init__ handling of the loaded mesh.")
        torch_model = None
    print("-" * 50)
else:
    torch_model = None

# Broadcast initialization status
init_status = COMM.bcast(pytorch_model_initialized, root=MODEL_RANK)
if not init_status and COMM.rank == MODEL_RANK:
     print("Terminating script because PyTorch model failed to initialize on rank 0.")
if not init_status:
    COMM.Barrier()
    sys.exit(1)

# ==============================================
# 5. FEniCSx/UFL Calculation
# ==============================================
# (Keep the FEniCSx calculation block exactly as before)
# ...
total_energy_ufl = float('nan')
if COMM.rank == MODEL_RANK:
    print("Performing FEniCSx/UFL Calculation...")

# Material parameters for UFL
E = Constant(domain, E_val)
nu = Constant(domain, nu_val)
mu = E / (2 * (1 + nu))
lmbda = E * nu / ((1 + nu) * (1 - 2 * nu))

# Kinematics
d = tdim
I = ufl.Identity(d)
F_ufl = I + ufl.grad(u)
C_ufl = F_ufl.T * F_ufl
Ic_ufl = ufl.tr(C_ufl)
J_ufl = ufl.det(F_ufl)

# Define Strain Energy Density (psi)
if USE_TORCH_INTERNAL_FORMULA:
    print("Using FEniCSx formula: 0.5*mu*(Ic-d-2*ln(J)) + 0.25*lmbda*(J^2-1-2*ln(J))")
    J_safe_ufl = ufl.conditional(ufl.gt(J_ufl, 1e-10), J_ufl, 1e-10)
    ln_J_ufl = ufl.ln(J_safe_ufl)
    psi_ufl = 0.5 * mu * (Ic_ufl - d - 2.0 * ln_J_ufl) + \
              0.25 * lmbda * (J_ufl**2 - 1.0 - 2.0 * ln_J_ufl)
else:
    print("Using FEniCSx formula: (mu/2)*(Ic-d) - mu*ln(J) + (lmbda/2)*(ln(J))^2")
    J_safe_ufl = ufl.conditional(ufl.gt(J_ufl, 1e-10), J_ufl, 1e-10)
    ln_J_ufl = ufl.ln(J_safe_ufl)
    psi_ufl = (mu / 2.0) * (Ic_ufl - d) - mu * ln_J_ufl + (lmbda / 2.0) * (ln_J_ufl)**2

# Choose Quadrature Degree
quad_degree = 1
if COMM.rank == MODEL_RANK: print(f"Using FEniCSx Quadrature Degree: {quad_degree}")

# Define integral
dx_explicit = ufl.dx(metadata={'quadrature_degree': quad_degree})
energy_form_ufl = fem.form(psi_ufl * dx_explicit)

# Compute total energy
total_energy_ufl = fem.assemble_scalar(energy_form_ufl)

if COMM.rank == MODEL_RANK:
    print(f"\n--- FEniCSx Results ---")
    print(f"Total Energy (FEniCSx): {total_energy_ufl:.8e}")
    # (Keep the intermediate value evaluation section, acknowledging it might fail)
    # ... FEniCSx intermediate value evaluation try/except block ...
    try:
        if torch_model: # Only proceed if torch model exists
            ref_coords_np = torch_model.quadrature_points[TEST_QUAD_POINT_IDX].cpu().numpy()
            physical_coords_np = get_physical_coords(domain, TEST_ELEMENT_IDX, [ref_coords_np]) # Pass as list

            if physical_coords_np is not None and len(physical_coords_np) > 0:
                print(f"Physical coords for comparison: {physical_coords_np[0]}")
                eval_points = physical_coords_np
                try:
                     bb_tree = dolfinx.geometry.BoundingBoxTree(domain, domain.topology.dim)
                     cell_candidates = dolfinx.geometry.compute_collisions(bb_tree, eval_points)
                     # Find cells containing the points
                     # NOTE: This returns list of cells for *each* point. We only use the first point.
                     cells_containing_points = dolfinx.geometry.compute_colliding_cells(domain, cell_candidates, eval_points)

                     # Check if any cell found for the first point
                     if cells_containing_points.num_nodes > 0 and cells_containing_points.links(0).size > 0:
                         eval_cell_idx = cells_containing_points.links(0)[0] # Use first cell found for first point
                     else:
                         # Fallback if point not found in any cell (might be outside domain slightly)
                         print("Warning: Evaluation point not found in any cell via BBox Tree. Using TEST_ELEMENT_IDX as fallback.")
                         eval_cell_idx = TEST_ELEMENT_IDX

                     print(f"(Eval using cell index: {eval_cell_idx})")

                     expr_F = fem.Expression(F_ufl, eval_points)
                     expr_J = fem.Expression(J_ufl, eval_points)
                     expr_Ic = fem.Expression(Ic_ufl, eval_points)
                     expr_psi = fem.Expression(psi_ufl, eval_points)
                     expr_detJ_ref = fem.Expression(ufl.JacobianDeterminant(domain), eval_points)

                     # Perform evaluation using the identified cell
                     F_val_ufl_eval = expr_F.eval([eval_cell_idx], eval_points)[0]
                     J_val_ufl_eval = expr_J.eval([eval_cell_idx], eval_points)[0]
                     Ic_val_ufl_eval = expr_Ic.eval([eval_cell_idx], eval_points)[0]
                     psi_val_ufl_eval = expr_psi.eval([eval_cell_idx], eval_points)[0]
                     detJ_ref_val_ufl_approx_eval = expr_detJ_ref.eval([eval_cell_idx], eval_points)[0]

                     print(f"\nIntermediate Values @ Elem {TEST_ELEMENT_IDX}, QP {TEST_QUAD_POINT_IDX} (via FEniCSx Expression):")
                     print(f"  F (deformation gradient):\n{F_val_ufl_eval.reshape(tdim, tdim)}")
                     print(f"  J (det(F)): {J_val_ufl_eval:.8e}")
                     print(f"  Ic (tr(C)): {Ic_val_ufl_eval:.8e}")
                     print(f"  psi (energy density): {psi_val_ufl_eval:.8e}")
                     print(f"  detJ_ref (approx): {detJ_ref_val_ufl_approx_eval:.8e}")

                except RuntimeError as eval_err_rt:
                     # Catch specific runtime errors often seen if point is outside cell domain for eval
                     print(f"\n!!! Runtime Error during fem.Expression.eval: {eval_err_rt}")
                     print("    Point might be outside the determined cell's reference domain.")
                     print("    Skipping FEniCSx intermediate value printout.")
                except Exception as eval_err:
                    print(f"\n!!! Error during fem.Expression.eval: {eval_err}")
                    print("    Skipping FEniCSx intermediate value printout.")
            else:
                print("\nCould not determine physical coordinates for FEniCSx intermediate evaluation.")
        else:
             print("\nSkipping FEniCSx intermediate value evaluation (PyTorch model not available).")
    except Exception as e:
        print(f"\n!!! Error preparing for or evaluating FEniCSx expressions: {e}")
        print("    Skipping FEniCSx intermediate value printout.")
    print("-" * 50)

# ==============================================
# 6. PyTorch Calculation
# ==============================================
# (Keep the PyTorch calculation block exactly as before)
# ...
total_energy_torch = float('nan')
if COMM.rank == MODEL_RANK and torch_model:
    print("Performing PyTorch Calculation...")
    u_tensor = torch.tensor(u_dof_values_np, device=DEVICE, dtype=DTYPE)
    try:
        total_energy_torch_tensor = torch_model.compute_energy(u_tensor)
        total_energy_torch = total_energy_torch_tensor.item()
        print(f"\n--- PyTorch Results ---")
        print(f"Total Energy (PyTorch): {total_energy_torch:.8e}")
        # (Keep intermediate value calculation and printing)
        # ... PyTorch intermediate value calculation and printing block ...
        print(f"\nIntermediate Values @ Elem {TEST_ELEMENT_IDX}, QP {TEST_QUAD_POINT_IDX} (from PyTorch internals):")
        element_node_indices = torch_model.elements[TEST_ELEMENT_IDX]
        u_reshaped = u_tensor.view(torch_model.num_nodes, torch_model.dim)
        element_disps = u_reshaped[element_node_indices]
        dN_dx_q = torch_model.dN_dx_all[TEST_ELEMENT_IDX, TEST_QUAD_POINT_IDX]
        detJ_ref_q = torch_model.detJ_all[TEST_ELEMENT_IDX, TEST_QUAD_POINT_IDX]
        grad_u_q = torch.einsum('nk,nj->jk', element_disps, dN_dx_q)
        I_torch = torch.eye(torch_model.dim, dtype=DTYPE, device=DEVICE)
        F_q = I_torch + grad_u_q
        J_q = torch.linalg.det(F_q)
        C_q = F_q.T @ F_q
        Ic_q = torch.trace(C_q)
        W_q_tensor = torch_model._compute_neohookean_energy_density(F_q.unsqueeze(0)).squeeze(0)
        W_q = W_q_tensor.item()
        print(f"  dN_dx:\n{dN_dx_q.cpu().numpy()}")
        print(f"  detJ_ref: {detJ_ref_q.item():.8e}")
        print(f"  grad(u):\n{grad_u_q.cpu().numpy()}")
        print(f"  F (deformation gradient):\n{F_q.cpu().numpy()}")
        print(f"  J (det(F)): {J_q.item():.8e}")
        print(f"  Ic (tr(C)): {Ic_q.item():.8e}")
        print(f"  W (energy density): {W_q:.8e}")
        quad_weight_q = torch_model.quadrature_weights[TEST_QUAD_POINT_IDX]
        point_energy_contribution = W_q * detJ_ref_q.item() * quad_weight_q.item()
        print(f"\n  Quadrature Weight: {quad_weight_q.item():.8e}")
        print(f"  Energy Contribution (W * detJ_ref * weight): {point_energy_contribution:.8e}")

    except Exception as e:
        print(f"\n!!! Error during PyTorch calculation or intermediate value extraction: {e}")
        import traceback
        traceback.print_exc()
    print("-" * 50)
elif COMM.rank == MODEL_RANK:
    print("Skipping PyTorch Calculation (Model initialization failed or not available).")
    print("-" * 50)

# ==============================================
# 7. Final Comparison
# ==============================================
# (Keep the Final Comparison block exactly as before)
# ...
if COMM.rank == MODEL_RANK:
    print("--- Final Energy Comparison ---")
    ufl_en = total_energy_ufl if isinstance(total_energy_ufl, (float, np.float64)) else float('nan')
    torch_en = total_energy_torch if isinstance(total_energy_torch, (float, np.float64)) else float('nan')
    print(f"Total Energy (FEniCSx): {ufl_en:.8e}")
    print(f"Total Energy (PyTorch): {torch_en:.8e}")
    if not np.isnan(ufl_en) and not np.isnan(torch_en):
        diff = abs(ufl_en - torch_en)
        avg_abs_val = (abs(ufl_en) + abs(torch_en)) / 2.0
        if avg_abs_val > 1e-12:
            rel_diff = diff / avg_abs_val
        elif diff < 1e-12:
             rel_diff = 0.0
        else:
             rel_diff = float('inf')
        print(f"Absolute Difference:   {diff:.8e}")
        print(f"Relative Difference:   {rel_diff:.8e}")
    else:
        print("Could not compute difference due to NaN results.")
    print("=" * 50)

# Ensure all ranks finish before exiting
COMM.Barrier()